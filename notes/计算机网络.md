- 计算机网络定义：互联的、自治的计算机集合
  - 自治：无主从关系
  - 互联：互联互通
- 主机与交换网络相连。交换网络里面有交换节点（路由器或交换机）
- 什么是Internet？
  - 全球最大的**互联网络**
    - 通过ISP（Internet Service Provider）联系在一起，是网络之网络，分全球ISP，区域ISP。
    - Internet是数以百万级的互连计算设备集合。
    - 分组交换方式相连
  - 为网络应用提供通信服务的通信基础设施
  - 为网络应提供编程接口
  - 需要**设备**和**协议**同时作用，达到顺利链接的目的
- **协议**是数据交换中事先约定好的规则，规定了通信实体之间交换信息的**格式**，**意义**，**顺序**以及针对收到信息或发生的事件所采取的**动作**
  - 三要素：
    - 语法
      - 数据与控制信息的结构或格式
      - 信号电平
    - 语义
      - 需要发出何种控制信息
      - 完成和中动作以及何种响应
      - 差错控制
    - 时序
      - 事件顺序
      - 速度匹配
- 计算机网络结构
  - 网络边缘
    - 主机（端系统）
      - 客户/服务器应用模型
        - 客户发送请求，接收服务器响应
      - 对等（peer-peer, P2P）应用模型：
        - 无（或不仅依赖）专用服务器
        - 通信在对等实体之间直接进行
    - 网络应用
  - 接入网络，物理介质
    - 有线或无线通信链路
      - 如何将网络边缘接入核心网
        - 典型模型：
          - 数字用户模型(DSL): 频分多路复用，(ADSL：非对称模型，上行下行速率不一样)
            - 利用已有的电话线接入
            - 独占
          - 电缆网络：
            - 频分多路复用：在不同频带传输不同信号
            - HFC：混合光纤同轴电缆，不同于DSL的独占至中心局的接入。
          - 机构接入网络
          - 无线接入网络：通过**基站**或称为**接入点**
            - LANs无线局域网
            - 广域无线接入（蜂窝网）
  - 网络核心（核心网络）
    - 关键功能：路由+转发
      - 路由：确定分组从源到目的传输路径
      - 转发：将分组从路由器的输入端口交换至正确的输出端口
    - 数据交换技术
      - 动态转接：端口到端口
      - 动态分配传输资源
      - 类型：
        - 电路交换
          - 最典型的交换网络：电话网络
          - 三个阶段：
            - 建立连接
            - 通信
            - 释放连接
          - 主要特点：**资源独占**：通信资源独占，而不是电路资源
          - 中继线共享：多路复用技术
            - 每路呼叫独占分配到的资源片进行通信
            - 分为：频分(FDM)，时分(TDM)，波分(WDM)，码分(CDM)
              - 频分：信号调制到不同的频带上。在用户分配了频带后，通信期间不变
              - 时分：将时间划分为一段段等长的**时分复用帧**，每个用户在每个TDM帧中占用固定序号的**时隙**
              - 波分：光通信中的频分复用
              - 码分：广泛用于无线通信（蜂窝网，卫星通信等）
                - 每个用户分配唯一的 m bit 码片序列，各用户使用相同的频率载波，利用各自码片序列编码数据
                - 编码信号=(原始数据)x(码片序列)  ---原始数据 = -1(0) / 1(1), 码片序列会比较长，对每个用户固定， 一个原始数据作用在一段码片上
                - 各用户的码片序列必须正交，所以才会提取出对应用户的信息
                - 信道传输的是各用户的叠加向量
        - 报文交换
          - 报文：源（应用）发送信息整体
          - 交换机收到整个报文后，再决定转发给谁
        - 分组交换
          - 分组：把报文进行拆分成一系列小数据包
          - 会给数据装上数据头，数据头+数据=分组
          - 需要报文的拆分与分组，会产生额外开销
          - 源主机向交换机发送分组的时候，交换机也会向目的主机发送已经接受到的分组
          - **统计多路复用**：分组序列不确定，按需共享链路
        - 报文交换与分组交换均采用存储-转发的交换方式
          - 报文交换以完整的报文进行存储-转发 (路由器所需缓存较大, 时间较长，串行)
          - 分组交换用较小的分组进行存储-转发 (路由器所需缓存较小，时间较短，并行)，报文交付时间（报文：Mbits, 链路带宽：Rbps, 分组大小：Lbits, 跳步数：h, 路由器数：n）：T = M/R + (h - 1) L/R = M/R + nL/R
      - 分组交换适用于突发数据传输网络
      - 可能产生拥塞：分组延迟和丢失
    - 互联的路由器（或分组转发设备）
    - 网络之网络
- Internet网络结构：
  - 端系统通过接入ISP（access ISPs）连接到Internet
  - 接入ISP必须进一步互联，构成复杂的网络互联的网络
  - 动态性比较强
  - ISP之间通过对等链路，IXP(Internet exchange point), 区域网络(regional net), 运营商网络进行互联
- 计算机网络性能
  - 速率：即数据率或数据传输速率或比特率，往往指额定速率
  - 带宽：原本指信号频带宽度。网络中通常指数字信道最高数据率 b/s bps
  - 延迟/时延 (delay或latency)：分组在路由器进行排队，如果缓存满，发生丢包
    - 节点处理延迟：差错检测，确定输出链路 d_proc
    - 排队延迟：等待输出链路可用，取决于路由器拥塞程度 d_queue
      - 设R:链路带宽，L:分组长度，a:平均分组到达速率
      - 流量强度：La/R 
        - ~0:平均排队延迟很小
        - ->1:平均排队延迟很大
        - *>*1:平均排队延迟无限大
    - 传输延迟：取决于分组长度和链路带宽 d_trans
    - 传播延迟：取决于物理链路长度和信号传播速度 d_prop
    - 时延带宽积 = 传播时延 x 带宽 = d_prop x R(btis)。又称以比特为长度的链路长度。
    - 丢包率：丢包数/发包总数
    - 吞吐量：在发送端与接收端之间的数据速率(b/s)： 即时吞吐量：给定时刻的速率。平均吞吐量：一段时间的平均速率。共享链路计算的时候用原吞吐量/共享数，取决于链路上吞吐量最小的链路（瓶颈链路）
- 网络结构：**分层结构**
  - 每层遵循某些网络协议完成本层功能
  - 计算机网络体系结构是各层即协议的集合，是功能层次以及关系的定义
  - **实体**表示任何可发送或接受信息的硬件或软件进程
  - 协议是控制**两个对等实体**进行通信的规则的集合，协议是**水平的**
  - 任一层实体需要使用下层服务，遵循本层协议，实现本层功能，向上层提供服务，服务是**垂直的**
  - 下层协议的实现对上层的服务用户是**透明**的
  - 同系统的相邻实体间通过**接口**进行交互，通过**服务访问点SAP**(Service Access Point)，交换**原语**，指定请求的特殊服务
- OSI参考模型：目的是支持**异构网络系统**的互联互通
  - 七层模型：
    - 主机要完成七个层（应用层，表示层，会话层，传输层，网络层，数据链路层，物理层）
    - 中间系统要完成三个层（网络层，数据链路层，物理层）
    - 只在主机实现的层称为**端到端层**
    - 每层都会加上自己层的控制头，数据链路层还会加尾，物理层不会加头尾。每层数据称为PDU（协议数据单元）
    - 数据封装的目的：增加控制信息
      - 地址：识别发送端/接收端
      - 差错检测编码
      - 协议控制：实现协议的附加信息：如优先级（priority），服务质量（QoS）和安全控制等
    - 物理层：实现每一个比特的传输
      - 需要比特编码（通信相关，调制等），数据率（多快去发送），比特同步（利用时钟同步），传输模式（单工，半双工，全双工）
    - 数据链路层：负责节点到节点的数据传输，解决物理链路直接相连的两个相邻节点之间的数据传输。以帧为数据单位来进行传输。需要组帧，以及**物理寻址**
      - 注意，物理寻址发生在数据链路层：在帧头增加发送端/接收端的物理地址标识数据帧（在广播通信中，所有节点都能收到其他节点发出的数据，帧头必须包含源物理地址和目的物理地址）
      - 要解决**流量控制**，避免淹没接收端
      - 需要**差错控制**
      - 可以实现**访问(接入)控制**：在给定时刻决定哪个设备拥有链路控制使用权
    - 网络层：负责源主机到目的主机**数据分组交付**
      - 可能穿越多个网络
      - 需要**逻辑寻址**：全局唯一逻辑地址，如IP
      - **路由**：选路径
      - **分组转发**：整个传输过程中需要重新包装，但源和目的的网络层地址不变
    - 传输层：（数据段）负责源-目的（端到端）（进程间）完整的报文传输
      - 包括报文**分段**和**重组**（基本单元：数据段）
      - 需要SAP寻址，将完整包文提交给正确**进程**。需要源和目的的SAP地址放在数据头
      - 实现端到端的连接控制（逻辑连接），流量控制，差错控制
    - 会话层：进行**对话控制**：建立和维护对话。以及**同步**，在数据流中插入同步点，便于数据中断恢复。不会对数据进行分割（实际不单独存在）
    - 表示层：处理两个系统间交换信息的语法与语义（实际不单独存在）
      - **数据表示转化**：转换为主机独立的编码（通用的表示方式，与系统无关）
      - **加密解密，压缩/解压缩**
    - 应用层：HTTP，FTP，SMTP等协议，支持用户通过用户代理（浏览器）或网络接口**使用网络**
- TCP/IP模型：
  - 应用层（HTTP,SMTP...）
  - 运输层（TCP，UDP）
  - 网际层（IP）(Everything over IP)
  - 网络接口层(没有相关协议，可以封装IP分组就可以)(IP over Everything)
- 五层参考模型：综合OSI(理论)和TCP/IP(实践)优点
  - 应用层：支持网络应用(用户发出的数据，**报文**)
  - 传输层：进程-进程数据传输（TCP, UDP）(加头，构造**段(segmentation)**)
  - 网络层：源主机到目的主机的数据分组路由与转发（IP协议，路由协议等）(加头，构造**数据报(datagram)**)
  - 数据链路层：相邻网络元素（主机，交换机，路由器）的数据传输（以太网Ethernet, WiFi）(加头加尾，构造**帧(frame)**)
  - 物理层：比特传输
  - 源主机和目的主机实现五层
  - 交换机(switch)实现链路层和物理层
  - 路由器(router)实现网络层，链路层和物理层
- 应用层：
  - 网络应用
    - 网络应用的体系结构：
      - 客户机/服务器结构(Client-Server, C/s)
        - 服务器是对外服务的软件，客户端请求服务
          - 服务器有永久性访问的地址/域名，7x24小时提供服务。(Web)
      - 点对点结构(Peer-to-peer, P2P)
        - 没有永远在线的服务器，任意端/节点之间可以直接通讯
        - 节点间歇性接入网络
        - 节点可能改变IP地址
      - 混合结构
        - E.g. Napster
          - 文件传输使用P2P
          - 文件搜索采用C/S结构--集中式
            - 每个节点向中央服务器登记自己的内容
            - 每个节点向中央服务器提交查询请求，查找感兴趣的内容
    - 网络应用进程通信
      - 同一主机上进程通信：
        - 进程间通信机制，操作系统提供
      - 不同主机上运行的进程通信：
        - 消息交换
        - 客户机进程：发起通信的进程
        - 服务器进程：等待通信请求的进程
      - 套接字：Socket
        - 进程间通信利用socket发送/接受消息
        - 传输基础设施向进程提供API。
      - 如何寻址进程：
        - 不同主机上进程间的通信，每个进程必须拥有标识符。
        - 利用**IP地址**寻址主机
        - 利用端口号/Port number寻址进程
          - HTTP Server: 80
          - Mail Server:25
        - 进程的标识符：IP地址+端口号
    - 应用层协议：网络应用需遵循应用层协议（公开协议由RFC(Request For Comments)定义，允许互操作，HTTP, SMTP，私有协议由多数P2P文件应用）
      - 内容：
        - 消息的类型：请求消息，响应消息...
        - 消息的语法/格式
        - 字段的语义
        - 规则
      - 网络应用的需求
        - 数据丢失/可靠性
        - 时间/延迟
        - 带宽
    - 传输层服务
      - Internet提供的传输服务（协议）：
        - TCP服务：
          - 面向链接：客户机/服务器进程间需要建立链接（全双工）
          - 可靠传输
          - 流量控制：发送方发送速度不会超过接收方处理能力（传输层）
          - 拥塞控制：网络负载过重的时候能够限制发送方的发送速度（传输层）
          - 不提供时间/延迟保障
          - 不提供最小带宽保障
        - UDP服务
          - 无连接
          - 不可靠的数据传输
          - 不提供可靠性，流量，拥塞，延迟保障，带宽保障
    - Web：
      - 网页(Web Page)包含多个对象(objects)
        - 对象：HTML文件、JPEG图片，视频文件、动态脚本等
        - 基本HTML文件：包含对其他对象引用的链接
        - 网页对象的寻址：
          - 通过URL(Uniform Resource Locator): 统一资源定位器：格式：协议省略的时候默认为HTTP
          ```
          Scheme://host:port/path
          www.usc.edu/myUSC
          host name  / path name 
          ```
        - web应用层协议：HTTP(HyperText Transfoer Protocol)超文本传输协议
          - 采用C/S结构
            - 客户：请求、接收、展示Web对象
            - 服务器：Web Server:响应用户的请求，发送对象
        - web传输层协议：
          - 服务器使用80端口等待请求
          - 浏览器发起到副武器的TCP链接（创建套接字Socket）
          - 服务器接受来自浏览器的TCP连接
          - 浏览器（HTTP客户端）与Web服务器（HTTP服务器）交换HTTP消息
          - 关闭TCP连接
        - 无状态：
          - 服务器不维护客户端过去所发送的请求。
        - HTTP两种连接类型
          - 非持久性连接：每个TCP连接仅允许最多传输一个对象
            - 假定用户在浏览器中输入URL: www.someSchool.edu/someDepartment/home.index 包含文本和指向10个jpeg图片的连接
              1. HTTP客户端向地址为www.someSchool.edu的服务器上的HTTP服务器进程（端口80）发起TCP连接请求
              2. HTTP服务器在端口80等待TCP连接请求，接受连接并且通知客户端
              3. HTTP将HTTP请求消息（包含URL地址）通过TCP连接的套接字发出，消息中所含的URL表明客户端需要对象 someDepartment/home.index
              4. HTTP服务器收到请求消息，解析，产生包含所需要对象的响应消息，并通过套接字发给客户端
              5. HTTP服务器关闭TCP连接
              6. HTTP客户端收到响应消息，解析HTML文件，显示HTML文件，发现有10个指向jpeg对象的超链接
              7. 为每个jpeg对象重复步骤1-5
          - 持久性连接：每个TCP连接允许传输多个对象
            - 无流水(pipelining)的持久性连接
              - 客户端只有收到前一个响应后才发送信的请求
              - 每个**被引用**的对象耗时1个RTT
            - 带有流水机制的持久性连接
              - 客户端只要遇到一个引用对象就尽快发出请求
              - 理想情况下，收到所有引用对象只需要耗时约1个RTT
          - 响应时间分析：
            - RTT（Round Trip Time）：从客户端发送一个很小的数据包到服务器并返回所经历的时间
            - 非持久性：
              - 发起，简历TCP连接：1RTT
              - 发起HTTP请求消息到HTTP响应消息前几个字节到达：1RTT
              - 响应消息中所含的文件/对象传输时间
              - Total = 2RTT + 文件发送时间
              - 问题：
                - 每个对象需要2个RTT
                - 操作系统需要为每个TCP连接开销资源
                - 浏览器会打开多个并行TCP连接以获取网页所需对象
            - 持久性：
              - 无流水：12个RTT
              - 有流水：3个RTT
        - HTTP协议消息：（**请求-响应模式**）
          - 请求消息：ASCII：人类可读
            1. 请求行：GET url HTTP版本
            2. 头部行：表示要访问的主机，客户端版本号...（可扩展）
            3. 空行（表明结束）
            4. Entity body
            
            ![Alt text](img/NETWORK_HTTP.png)
            - 上传输入的方法
              - POST方法：
                - 在请求消息的消息体中上传客户端的输入(第一行GET改成POST)
                - URL方法：
                  - 使用GET方法
                  - 输入信息通过request行的URL字段上传
                  
                  www.somesite.com/animalsearch?monkeys&banana
            - HTTP方法类型：
              - GET：从浏览器获得
              - POST：往服务器端提交数据
              - HEAD: 请server不要将请求的对象放入响应消息中（只返回头部，用来测试）
              - PUT（HTTP/1.1）：将消息体中文件上传到URL字段所指定的路径（WEB服务器上传文件）
              - DELETE（HTTP/1.1）：删除URL字段所指定的文件
          - HTTP响应消息：
            1. status line(protocol, status code, status phrase) HTTP/1.1 200 OK
            2. header lines
            3. 空行
            4. data 
        - Cookie技术
          - HTTP协议无状态，但很多服务器需要掌握客户端的状态。
          - 某些网站为了辨别用户身份、进行session跟踪而存储在用户本地终端上的数据
          - 组件：
            - HTTP响应消息的cookie头部行
            - HTTP请求消息的cookie头部行
            - 保存在客户端主机上的cookie文件，由浏览器管理
            - Web服务器端的后台数据库
          - 原理：
          
            ![Alt text](img/NETWORK_cookie.png)
        - Web缓存/代理服务器技术
          - 功能：在不访问服务器的前提下满足客户端的HTTP请求
          - 目的：缩短客户请求时间，减少机构/组织流量，在大范围内实现有效的内容分发
          - 在客户和服务器间假设了一个代理服务器(Proxy server), 用户设定浏览器通过缓存进行Web访问
          - 浏览器向缓存/代理服务器发送所有的HTTP请求
            - 如果请求对象在缓存中，缓存返回对象
            - 否则，缓存服务器向原始服务器发送HTTP请求，获取对象，然后返回给客户端并保存该对象
          - 缓存既充当客户端，也充当服务器
          - 一般有ISP(Internet服务提供商)架设
          - 条件性GET方法：解决缓存与远端不同步的问题：
            - 如果缓存有最新版本，则不需要发送请求对象
            - 缓存：
              - 在HTTP请求消息中声明所持有版本日期
              - If-modified-since: &lt;date&gt;
            - 服务器：
              - 如果缓存的版本是最新的，则响应信息中不包含对象
              - HTTP/1.0 304 Not Modified

          ![Alt](img/NETWORK_conditional_get.png)
    - Email: 
      - 应用构成：
        - 邮件客户端(user agent)(外围)
          - 与服务器交互，收、发邮件
        - 邮件服务器(核心)
          - 邮箱：储存发给该用户的Email
          - 消息队列：存储等待发送的Email
        - SMTP协议(Simple Mail Transfer Protocol)
          - 邮件服务器之间传递消息所使用的协议
          - 客户端：发送消息的服务器
          - 服务器：接收消息的服务器
          - 使用TCP
          - 端口25
          - 传输过程的三个阶段：
            - 握手
            - 消息传输
            - 关闭
          - **命令/响应交互**模式
            - 命令(command)：ASCII文本
            - 响应(response): 状态码和语句
          - 异步应用
          
            ![Alt text](img/NETWORK_email_app.png)
         
      - 采用邮件服务器的好处：
        - HTTP无法保证24小时在线
        - 发邮件必须保证送达，否则一直重发
      - 与HTTP对比：
        - HTTP：拉式(pull)
        - SMTP: 推式(push)
        - 都使用命令/响应交互模式
        - 命令和状态码都是ASCII码
        - HTTP: 每个对象封装在独立的响应消息中
        - SMTP: 多个对象在由多个部分构成的消息中发送
      - Email消息格式：
        - SMTP: email消息的传输/交换协议
          - 头部行: To, from, subject，与SMTP命令不同
          - 消息体：消息本身，只能是ASCII字符
        - MIME多媒体邮件扩展：
          - 通过在邮件头部增加额外的行以声明MIME的内容类型。
          - 要把文件类型，编码方式都发送过去，具体文件应该转换成编码后的(ASCII)数据
      - 邮件访问协议：从服务器获取邮件
        
        ![Alt text](img/NETWORK_email_access.png)
        1. POP(Post Office Protocol)
           - 认证/授权(客户端&lt;--&gt;服务器)和下载
           - 认证过程：
             - 客户端命令：
               - User：声明用户名
               - Pass：声明密码
             - 服务器响应：
               - +OK
               - -ERR
           - 事务阶段：
             - List: 列出消息数量
             - Retr: 用编号获取消息
             - Dele: 删除消息
             - Quit
           - POP3是无状态的
        2. IMAP(Internet Mail Access Protocol)
           - 功能比较复杂，可以操纵服务器上存储的信息
           - 所有消息同意保存在服务器
           - 允许用户用文件夹组织消息
           - 支持跨会话(Session)的用户状态(有状态)
        3. HTTP
    - DNS(Domain Name System，域名解析系统)：解决Internet上主机/路由器的识别问题（域名和IP地址之间的映射）
      - 是一个由多层命名服务器构成的分布式数据库
      - 应用层协议：完成名字的解析
      - DNS服务：
        - 域名向IP地址翻译
        - 主机别名
        - 邮件服务器别名
        - 负载均衡：Web服务器
      - 为什么不适用集中式DNS:
        - 单点失败问题：DNS坏了，互联网会瘫痪
        - 流量问题
        - 距离问题
        - 维护性问题
      
      ![Alt text](img/NETWORK_DNS.png)
      1. Root DNS Server(根域名)
        - 本地域名解析服务器无法解析域名时，访问根域名服务器
         - 如果不知道映射，访问权威域名服务器，获得映射，向本地域名服务器返回映射
      2. com, org, edu DNS Server(顶级域名)
         - 顶级域名服务器(TLD, top-level domain), 负责com, org, net, edu, cn, uk, fr 等
      4. 权威(Authoritative)域名
         - 组织的域名解析服务器，提供组织内部服务器的解析服务
      1. 本地域名解析服务器(不严格属于层级体系)
         - 每个ISP都有一个本地域名服务器，也称为默认域名解析服务器
         - 当主机进行DNS查询的时候，查询被发送到本地域名服务器
         - 作为代理(proxy)，将查询转发给（层级式）域名解析服务器系统
      - 查询www.amazon.com的IP地址：
        1. 客户端查询根服务器，找到com域名解析服务器
        2. 客户端查询com域名解析服务器，找到amazon.com域名解析服务器
        3. 客户端查询amazon.com域名解析服务器，获得www.amazon.com的IP地址
    - DNS查询示例：
      - Cis.ploy.edu主机想获得gaia.cs.umass.edu的IP地址
      - 迭代查询：
        - cis.poly.edu(requesting host)访问本地域名解析服务器(dns.poly.edu)
        - 本地域名解析服务器会首先访问root DNS server，根域名服务器返回顶级域名服务器地址(umass.edu)
        - 本地域名解析服务器再访问顶级域名服务器，顶级域名服务器将权威域名服务器的地址(dns.cs.umass.edu)返回
        - 本地域名解析服务器再访问权威域名服务器，权威域名服务器将IP地址(gaia.cs.umass.edu)返回

        ![Alt text](img/NETWORK_iterative_DNS.png)
      - 递归查询

        ![Alt text](img/NETWORK_recursive_DNS.png)
      - DNS记录缓存和更新
        - 只要域名解析服务器获得域名-IP映射，即缓存这一映射
        - 一段时间后，缓存条目失效(删除)
        - 本地域名服务器一般会缓存顶级域名服务器的映射，因此根域名服务器不经常被访问
      - DNS记录和消息格式
        - 资源记录：
          - RR(resource records)
          - format(name, value, type, ttl)
          - Type=A: Name:主机域名，Value:IP地址
          - Type=NS: Name:域(edu.cn), Value:该域权威域名解析服务器的主机域名
          - Type=CNAME: Name:某一真实域名的别名, Value: 真实域名
          - Type=MX: Value是与name对应的邮件服务器
        - 协议与消息
          - DNS协议：**查询/回复**类型
          
          ![Alt text](img/NETWORK_DNS_procotype.png)
          - 传输层协议：**DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议；**
            - DNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区传送（zone transfer）。 
            - 为什么既使用TCP又使用UDP？ 首先了解一下TCP与UDP传送字节的长度限制：UDP报文的最大长度为512字节，而TCP则允许报文长度超过512字节。当DNS查询超过512字节时，协议的TC标志出现删除标志，这时则使用TCP发送。通常传统的UDP报文一般不会大于512字节。 
            - 区域传送时使用TCP，主要有一下两点考虑：1.辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。2.TCP是一种可靠的连接，保证了数据的准确性。
            - 域名解析时使用UDP协议：客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。
    - P2P应用：文件分发
      - 特点：
        - 没有服务器
        - 任意端系统之间直接通信
        - 节点阶段性接入Internet
        - 节点可能更换IP地址
      - BitTorrent(BT)应用：
        - torrent:交换同一个文件的文件块的节点组
        - tracker:跟踪参与torrent的节点
        - 文件被划分为256KB的chunk
        - 节点加入torrent，一开始没有chunk，但是会逐渐积累。会向tracker注册以获得节点清单，与某些节点建立连接
        - 下载的同时，节点需要向其他节点上传chunk
        - 下载完成后，可能离开或留下
      - 获取chunk:
        - 给定任意时刻，不同的节点持有文件的不同chunk集合
        - 节点定期查询每个邻居所持有的chunk列表
        - 节点发送请求，请求获取缺失的chunk（稀缺优先）
      - 发送chunk: tit-for-tat
        - 每个节点向正在给自己发送文件的，速率最快的top4节点发送文件。每30秒随机选择一个其他节点，向其发送chunk
        - 上传速率高，则能更快的获取文件
    - P2P应用：索引技术
      - 系统索引：信息到节点位置（IP地址+端口号）的映射
      - 集中式索引：
        - 节点加入时，通知中央服务器IP地址和内容
        - A向中央服务器查找，中央服务器告诉A，文件在B处。
        - A与B建立连接，下载
        - 问题：
          - 单点失效问题，性能瓶颈，版权问题
      - 分布式索引（洪泛式查询Query flooding）：
        - 完全分布式架构
        - 每个节点对它共享的文件进行索引，且只对它共享的文件进行索引
        - 如何解决全局信息：
          - 覆盖网络（overlay network）:
            - 节点X与Y之间如果有TCP连接，则构成一个边
            - 所有活动节点和边构成覆盖网络
            - 边：虚拟链路
            - 节点一般邻居数少于10个
          - 通过已有TCP发送查询消息
          - 节点转发查询消息
          - 如果查询命中，利用反向路径发回查询节点
          - 会引起网络拥塞
      - 层次式覆盖网络（介于分布式和集中式之间）
        - 每一个节点或者是一个**超级节点**，或者**被分配**一个超级节点
          - 节点和超级节点间维持TCP连接
          - 某些超级节点对之间维持TCP连接
        - 超级节点负责跟踪子节点的内容
        - 超级节点之间洪泛式，超级节点和普通节点之间集中式（Skype）
  - 套接字编程（Socket）网络程序设计接口：应用层和传输层之间编程
    - 标识通信端点（对外）：IP地址+端口号
    - 操作系统/进程管理套接字（对内）：套接字描述符(socket descriptor)
    - 类似于文件的抽象
    - 当应用进程创建套接字时，操作系统分配一个数据结构存储该套接字相关信息
    - 返回套接字描述符
    
    ![Alt text](img/NETWORK_socket_system.png)

    - 确定端口地址的结构：
    ```C++
    struct sockaddr_in {
        u_char sin_len; // 地址长度
        u_char sin_family // 地址族，使得该数据结构可以面向不同的协议(TCP/IP: AF_INET)
        u_short sin_port // 端口号
        struct in_addr sin_addr; // IP地址
        char sin_zero[8]; // 未用(置0)
    }
    ```
    - WinSock:
      - 首先调用WSAStartup(初始化Windows Sockets API)
      - 之后是应用程序
      - 最后WSACleanup(释放所使用的Windows Socket DLL)
      ```C++
      // WSAStartup函数
      int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);
      // 第一个参数指明程序请求使用的WinSock版本，其中高位字节指明副版本，低位字节指明主版本，16进制，0x102表示2.1版
      // 第二个参数返回实际的WinSock的版本信息，指向WSADATA结构的指针
      wVersionRequested = MAKEWORD(2, 1);
      err = WSAStartup(wVersionRequseted, &wsaData);
      
      // WSACleanup函数
      int WSACleanup(void);
      // 解除与Socket动态链接库的绑定，释放系统资源

      // socket函数
      sd = socket(protofamily, type, proto);
      // 创建套接字，操作系统返回套接字描述符(sd)
      //第一个参数(协议族): protofamily = PF_INET(TCP/IP)
      //第二个参数(套接字类型) type = SOCK_STREAM(TCP, 流式套接字), SOCK_DGRAM(UDP, 数据报套接字), SOCK_RAW(直接面向网络层, IP/ICMP/IGMP)
      // 第三个参数(协议号): 0为默认

      struct protoent *p;
      p = getprotobyname("tcp");
      SOCKET sd = socket(PF_INET, SOCK_STREAM, p->p_proto);
      
      // Closesocket
      int closesocket(SOCKET sd);
      // 关闭一个描述符为sd的套接字，引用计数 - 1, 至0关闭
      // 一个进程中的多线程对一个套接字的使用无计数

      // bind
      int bind(sd, localaddr, addrlen);
      // 绑定套接字的本地端点地址(IP地址+端口号)
      // sd: 套接字描述符
      // 端点地址(localaddr -> sockaddr_in)
      // 客户端程序一般不必调用bind函数
      // 服务器端要调用，使用地址通配符: INADDR_ANY解决一个服务端可能有多个IP地址(路由器)

      // listen
      int listen(sd, queuesize)
      // 置服务器端的流套接字处于被动监听状态
      // 仅用于服务器端调用，仅用于面向连接的流套接字
      // 设置连接请求队列大小(queuesize)

      // connect
      connect(sd, saddr, saddrlen);
      // 客户程序调用connect来使客户套接字(sd)与特定计算机的特定端口(saddr)的套接字(服务)进行连接 阻塞函数
      // 仅用于客户端
      // 可用于TCP客户端(建立TCP连接， 调用后会向服务端发送连接请求，返回值决定是否连接成功)和UDP客户端(指定服务器端点地址)

      // accept
      newsock = accept(sd, caddr, caddrlen);
      // 服务器程序调用accept从listen状态的流套接字sd的客户连接请求队列中取出第一个用户请求，并创建一个新的套接字来与客户套接字创建连接通道 阻塞函数
      // sd : 队列中客户发送的套接字
      // caddr, caddrlen : 客户端的套接字地址和长度
      // 仅用于TCP套接字
      // 仅用于服务器
      // 利用新创建的套接字 newsock 与客户端通信。创建新套接字以实现并发服务器：TCP特点：面向连接的有序可靠点对点的连接协议，意味着一个套接字只能连接服务端和客户端，如果没有新建立套接字，TCP服务器在某一时刻只能为某一个客户提供服务

      // send, sendto
      send(sd, *buf, len, flags); 
      // 没有指定目的地，用于TCP套接字（客户端和服务器端）或调用了connect函数的UDP客户端套接字
      sendto(sd, *buf, len, flags, destaddr, addrlen);
      // sendto用于UDP服务端套接字与未调用connect函数的UDP客户端套接字

      // recv, recvfrom
      recv(sd, *buffer, len, flags);
      recvfrom(sd, *buf, len, flags, senderaddr, saddrlen)

      // setsockopt, getsockopt
      int setsockopt(int sd, int level, int optname, *optal, int optlen);
      int getsockopt(int sd, int level, int optname, *optval, socklen_t* optlen);
      // 设置套接字sd的选项参数
      // 获取任意类型、任意状态套接口的选项当前值，并把结果存入optval
      ```
    - 网络字节顺序：
      - TCP/IP定义了标准的用于协议头中的二进制整数表示：**网络字节顺序**
      - 某些Socket API函数的参数需要存储为网络字节顺序(如IP地址，端口号等)
      - 可以实现本地字节顺序与网络字节顺序之间转换的函数：
        - htons: 本地字节顺序->网络字节顺序(16bits)
        - ntohs: 网络字节顺序->本地字节顺序(16bits)
        - htonl: 本地字节顺序->网络字节顺序(32bits)
        - ntonl: 网络字节顺序->本地字节顺序(32bits)
    - TCP调用基本流程
    
    ![Alt text](img/NETWORK_socket_flowchat.png)
