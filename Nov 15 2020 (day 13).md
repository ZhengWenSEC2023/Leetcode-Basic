# 算法班
## 快速排序算法 (分割)

要点： 
 1. while (left **<=** right)
    此处为了保证partition之后，left = right的情况不会出现死递归
 1. while (left <= right && nums[left] **<** pivot)
    此处为了符合quickSort partition的思想，使得数组均匀分割：**<= pivot的点在左，>= pivot的点在右**
        例子：当数组为：[1, 1, 1, 1, 1, 1, 1] 时，如果条件是 nums[left] <= pivot, 第一个while就会将left指针移动到数组末端，或造成四递归，或数组分割不平衡。
 1. 递归退出条件：**start >= end**, 剩余一个数或没有数的时候不用排序。
```C++
void sortIntegers(vector<int> &nums) {
    quickSort(0, nums.size() - 1, nums);
}

void quickSort(int start, int end, vector<int> &nums) {
    if (start >= end) {
        return;
    }

    int left = start, right = end;
    int pivot = nums[(left + right) / 2];

    while (left <= right) {
        while (left <= right && nums[left] < pivot) {
            left++;
        }
        while (left <= right && nums[right] > pivot) {
            right--;
        }

        if (left <= right) {
            swap(nums[left], nums[right]);
            left++; 
            right--;
        }
    }

    quickSort(start, right, nums);
    quickSort(left, end, nums);
}
```

## 归并排序算法 (归并)

要点： 
 1. 明确递归函数mergeSort的定义：对**[start, end]闭区间**的数组进行排序。
 1. merge的时候注意while和for循环都应该包括这两个端点
 1. 递归退出条件：**start >= end**

```C++
void sortIntegers(vector<int> &nums) {
    vector<int> temp(nums.size());
    mergeSort(0, nums.size() - 1, nums, temp);
}

void mergeSort(int start, int end, vector<int> &nums, vector<int> &temp) {
    if (start >= end)
        return;
    
    mergeSort(start, (start + end) / 2, nums, temp);
    mergeSort((start + end) / 2 + 1, end, nums, temp);
    merge(start, end, nums, temp);
}

void merge(int start, int end, vector<int> &nums, vector<int>temp) {
    int mid = (start + end) / 2;
    int leftIndex = start, rightIndex = mid + 1;
    int totalIndex = start;

    while (leftIndex <= mid && rightIndex <= end) {
        if (nums[leftIndex] < nums[rightIndex]) {
            temp[totalIndex++] = nums[leftIndex++];
        }
        else {
            temp[totalIndex++] = nums[rightIndex++];
        }
    }

    while (leftIndex <= mid) {
        temp[totalIndex++] = nums[leftIndex++];
    }
    while (rightIndex <= end) {
        temp[totalIndex++] = nums[rightIndex++];
    }

    for (int i = start; i < end; i++) {
        nums[i] = temp[i];
    }
}
```

## 快速选择 (分割) 

LintCode 5, 80

要点：
 1. 注意如何判断下一个递归函数，按照长度，带特例进行计算
 
```C++
int kthLargestElement(int n, vector<int> &nums) {
    // write your code here
    return quickSelect(0, (int)nums.size() - 1, nums, n);
    
}

int quickSelect(int start, int end, vector<int>& nums, int n) {
    if (start == end)
        return nums[start];
    
    int left = start, right = end;
    int pivot = nums[(left + right) / 2];

    while (left <= right) {
        while (left <= right && nums[left] > pivot) {
            left++;
        }
        while (left <= right && nums[right] < pivot) {
            right--;
        }
        if (left <= right) {
            swap(nums[left], nums[right]);
            left++; 
            right--;
        }
    }

    // 考虑 right 和 start 相等，且 n = 1; 此时应该去左边，注意此处区间定义为闭区间
    if (start + n - 1 <= right) 
        return quickSelect(start, right, nums, n);
    // 长度考虑当 left = 5, start = 0, 此时跳过了 0, 1, 2, 3, 4 个元素，所以长度为 left - start.
    if (start + n - 1 >= left) 
        return quickSelect(left, end, nums, n - (left - start));
    // 都不满足的话说明 right 和 left 中间空了一个元素，且位于 n 所在的位置
    return nums[right + 1];
}
```
