# 算法班
## 时间复杂度低于O（N）的算法

快速幂算法O(logN)、辗转相除法O(logN)、质因数分解O(sqrtN)、分块检索法O(sqrtN)。
- 快速幂：140, 递归法，迭代法
  - 加，减，乘对取余满足分配律，但除法不满足

- 分解质因数
  - 具体步骤
    1. 记up = sqrt{n}，作为质因数k的上界, 初始化k=2。
    1. 当k <= up 且 n不为1 时，执行步骤3，否则执行步骤4。
    1. 当n被k整除时，不断整除并覆盖n，同时结果中记录k，直到n不能整出k为止。之后k自增，执行步骤2。
    1. 当n不为1时，把n也加入结果当中，算法结束。
  - 几点解释
    - 不需要判定k是否为质数，如果k不为质数，且能整出n时，n早被k的因数所除。故能整除n的k必是质数。
    - 为何引入up？为了优化性能。当k大于up时，k已不可能整除n，除非k是n自身。也即为何步骤4判断n是否为1，n不为1时必是比up大的质数。
    - 步骤2中，也判定n是否为1，这也是为了性能，当n已为1时，可早停。
  - 代码
    ```python
    def primeFactorization(n):
        result = []
        up = int(math.sqrt(n));
        
        k = 2
        while k <= up and n > 1: 
            while n % k == 0:
                n //= k
                result.append(k)
            k += 1
                
        if n > 1:
            result.append(n)
            
        return result
    ```
  - 复杂度分析
    - 最坏时间复杂度O(sqrt (n) )。当n为质数时，取到其最坏时间复杂度。
    - 空间复杂度O(log(n)), 当n质因数很多时，需要空间大，但总不会多于O(log(n))个
- 后序遍历非递归
  1. 如果根节点非空，将根节点加入到栈中。
  2. 如果栈不空，取栈顶元素（暂时不弹出），
      - 如果（左子树已访问过或者左子树为空），且（右子树已访问过或右子树为空），则弹出栈顶节点，将其值加入数组
      - 如果左子树不为空，且未访问过，则将左子节点加入栈中，并标左子树已访问过。
      - 如果右子树不为空，且未访问过，则将右子节点加入栈中，并标右子树已访问过。
  3. 重复第二步，直到栈空。
  ```python
  class Solution:
    """
    @param root: A Tree
    @return: Postorder in ArrayList which contains node values.
    """
    def postorderTraversal(self, root):
        result = []
        stack = []
        prev, curr = None, root

        if not root:
            return result

        stack.append(root)
        while len(stack) > 0:
            curr = stack[-1]
            if not prev or prev.left == curr or prev.right == curr:  # traverse down the tree
                if curr.left:
                    stack.append(curr.left)
                elif curr.right:
                    stack.append(curr.right)
            elif curr.left == prev:                                  # traverse up the tree from the left
                if curr.right:
                    stack.append(curr.right)
            else:                                                    # traverse up the tree from the right
                result.append(curr.val)
                stack.pop()
            prev = curr

        return result
  ```

  ```C++
  // 左右根，所以入栈顺序应该为根右左
  class Solution {
  public:
      /**
      * @param root: A Tree
      * @return: Postorder in ArrayList which contains node values.
      */
      vector<int> postorderTraversal(TreeNode * root) {
          // write your code here
          if (root == NULL) {
              return {};
          }
          stack<TreeNode*> s;
          s.push(root);
          unordered_set<TreeNode*> visit;
          visit.insert(root);
          vector<int> res;
          while (!s.empty()) {
              TreeNode* cur_node = s.top();
              if ((!cur_node->left || visit.find(cur_node->left) != visit.end()) && (!cur_node->right || visit.find(cur_node->right) != visit.end())) {
                  res.push_back(cur_node->val);
                  s.pop();
              }
              if (cur_node->right && visit.find(cur_node->right) == visit.end()) {
                  s.push(cur_node->right);
                  visit.insert(cur_node->right);
              }
              if (cur_node->left && visit.find(cur_node->left) == visit.end()) {
                  s.push(cur_node->left);
                  visit.insert(cur_node->left);
              }
          }
          return res;
      }
  };
  ```
- 用 Morris 算法进行中序遍历(Inorder Traversal)
  1. 如果当前节点的左孩子为空，则输出当前节点并将其右孩子作为当前节点。
  1. 如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点。
      - 如果前驱节点的右孩子为空，将它的右孩子设置为当前节点。当前节点更新为当前节点的左孩子。
      -  如果前驱节点的右孩子为当前节点，将它的右孩子重新设为空（恢复树的形状）。输出当前节点。当前节点更新为当前节点的右孩子。
  1. 重复1、2两步直到当前节点为空。
  
  ![Alt text](notes/img/Morris1.jpg)

  上图为每一步迭代的结果（从左至右，从上到下），cur代表当前节点，深色节点表示该节点已输出。
  ```python
  class Solution:
    """
    @param root: A Tree
    @return: Inorder in ArrayList which contains node values.
    """
    def inorderTraversal(self, root):
        nums = []
        cur = None
    
        while root:
            if root.left:
                cur = root.left
                while cur.right and cur.right != root:
                    cur = cur.right
                
                if cur.right == root:
                    nums.append(root.val)
                    cur.right = None
                    root = root.right
                else:
                    cur.right = root
                    root = root.left
            else:
                nums.append(root.val)
                root = root.right
                
        return nums
  ```

- 用 Morris 算法实现先序遍历(Preorder Traversal)
  1. 如果当前节点的左孩子为空，则输出当前节点并将其右孩子作为当前节点。
  1. 如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点。
      - 如果前驱节点的右孩子为空，将它的右孩子设置为当前节点。输出当前节点（与中序遍历唯一一点不同）。当前节点更新为当前节点的左孩子。
      - 如果前驱节点的右孩子为当前节点，将它的右孩子重新设为空。当前节点更新为当前节点的右孩子。
  1. 重复1、2两步直到当前节点为空。

  ![Alt text](notes/img/Morris2.jpg)
  
  ```python
  class Solution:
    """
    @param root: A Tree
    @return: Preorder in ArrayList which contains node values.
    """
    def preorderTraversal(self, root):
        nums = []
        cur = None
        
        while root:
            if root.left:
                cur = root.left
                while cur.right and cur.right != root:
                    cur = cur.right
                if cur.right == root:
                    cur.right = None
                    root = root.right
                else:
                    nums.append(root.val)
                    cur.right = root
                    root = root.left
            else:
                nums.append(root.val)
                root = root.right
                
        return nums
  ```
- 用 Morris 算法实现后序遍历(Postorder Traversal)
 - 后序遍历其实可以看作是和前序遍历左右对称的，此处，我们同样可以利用这个性质，基于前序遍历的算法，可以很快得到后序遍历的结果。我们只需要将前序遍历中所有的左孩子和右孩子进行交换就可以了。
 ```python
 class Solution:
    """
    @param root: A Tree
    @return: Postorder in ArrayList which contains node values.
    """
    def postorderTraversal(self, root):
        nums = []
        cur = None

        while root:
            if root.right != None:
                cur = root.right
                while cur.left and cur.left != root:
                    cur = cur.left
                if cur.left == root:
                    cur.left = None
                    root = root.left
                else:
                    nums.append(root.val)
                    cur.left = root
                    root = root.right
            else:
                nums.append(root.val)
                root = root.left
                
        nums.reverse()
        return nums
 ```